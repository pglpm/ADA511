{
  "hash": "b0474c43c7fdb35486a4584969abe286",
  "result": {
    "engine": "knitr",
    "markdown": "# [The prototype Optimal Predictor Machine makes decisions]{.red} {#sec-example-opm2}\n::: {.hidden}\n<!-- $$\\require{mathtools}$$ -->\n\n\\providecommand{\\ul}{\\uline}\n\\providecommand{\\and}{\\mathbin{\\mkern-0.5mu,\\mkern-0.5mu}}\n\\renewcommand*{\\|}[1][]{\\nonscript\\:#1\\vert\\nonscript\\:\\mathopen{}}\n\\providecommand*{\\pr}[1]{\\textsf{\\small`#1'}}\n\\renewcommand*{\\pr}[1]{\\textsf{\\small`#1'}}\n\\providecommand*{\\prq}[1]{\\textsf{\\small #1}}\n\\providecommand*{\\se}[1]{\\mathsfit{#1}}\n\\renewcommand{\\se}[1]{\\mathsfit{#1}}\n\\providecommand*{\\sei}[1]{\\mathsfit{\\small #1}}\n<!-- \\providecommand{\\cat}[1]{\\texttt{\\small #1}} -->\n\\providecommand{\\cat}[1]{{\\small\\verb;#1;}}\n\\providecommand{\\vec}[1]{\\boldsymbol{#1}}\n\\providecommand{\\p}{\\mathrm{p}}\n\\renewcommand{\\p}{\\mathrm{p}}\n\\renewcommand{\\P}{\\mathrm{P}}\n\\definecolor{quarto-callout-note-color}{HTML}{4477AA}\n\\definecolor{quarto-callout-note-color-frame}{HTML}{4477AA}\n\\definecolor{quarto-callout-important-color}{HTML}{AA3377}\n\\definecolor{quarto-callout-important-color-frame}{HTML}{AA3377}\n\\definecolor{quarto-callout-warning-color}{HTML}{EE6677}\n\\definecolor{quarto-callout-warning-color-frame}{HTML}{EE6677}\n\\definecolor{quarto-callout-tip-color}{HTML}{228833}\n\\definecolor{quarto-callout-tip-color-frame}{HTML}{228833}\n\\definecolor{quarto-callout-caution-color}{HTML}{CCBB44}\n\\definecolor{quarto-callout-caution-color-frame}{HTML}{CCBB44}\n<!-- \\providecommand*{\\mo}[1][=]{\\mathrel{\\nonscript\\mkern-3mu\\textrm{\\small#1}\\nonscript\\mkern-3mu}} -->\n\\providecommand*{\\mo}[1][=]{\\mathclose{}\\mathord{\\nonscript\\mkern0mu\\textrm{\\small#1}\\nonscript\\mkern0mu}\\mathopen{}}\n\\providecommand*{\\yX}{\\se{X}}\n\\providecommand*{\\yY}{\\se{Y}}\n\\providecommand*{\\yI}{\\se{I}}\n\\providecommand*{\\yi}[1][]{\\se{I}_{\\text{#1}}}\n\\providecommand{\\di}{\\mathrm{d}}\n\\providecommand{\\defd}{\\coloneqq}\n\\providecommand{\\blue}{\\color[RGB]{68,119,170}}\n\\providecommand{\\red}{\\color[RGB]{238,102,119}}\n\\providecommand{\\purple}{\\color[RGB]{170,51,119}}\n\\providecommand{\\green}{\\color[RGB]{34,136,51}}\n\\providecommand{\\yellow}{\\color[RGB]{204,187,68}}\n\\providecommand{\\lblue}{\\color[RGB]{102,204,238}}\n\\providecommand{\\grey}{\\color[RGB]{187,187,187}}\n\\providecommand{\\midgrey}{\\color[RGB]{119,119,119}}\n\\providecommand{\\black}{\\color[RGB]{0,0,0}}\n\\providecommand*{\\e}{\\mathrm{e}}\n\\providecommand*{\\pu}{\\text{π}}\n\\providecommand*{\\RR}{\\mathbf{R}}\n\n$\\DeclarePairedDelimiter{\\set}{\\{}{\\}}$\n\\providecommand*{\\argmax}{\\operatorname{argmax}}\n<!-- \\DeclareMathOperator*{\\argmax}{argmax} -->\n\n<!-- \\renewcommand*{\\prq}[1]{\\textsf{\\small #1}} -->\n<!-- \\definecolor{lightblue}{HTML}{66CCEE} -->\n<!-- \\sethlcolor{lightblue} -->\n<!-- \\providecommand*{\\moo}[1][=]{\\mathord{\\mkern1.5mu#1\\mkern1.5mu}} -->\n<!-- \\providecommand*{\\mo}[1][=]{\\mathrel{\\mkern-4mu#1\\mkern-4mu}} -->\n<!-- \\providecommand*{\\mo}[1][\\textrm{\\small=}]{\\mathord{\\mkern1.5mu#1\\mkern1.5mu}} -->\n\n:::\n\n::: {.hidden}\n\\providecommand*{\\yon}{{\\green\\cat{on}}}\n\\providecommand*{\\yof}{{\\red\\cat{off}}}\n\\providecommand*{\\yy}{{\\lblue\\cat{Y}}}\n\\providecommand*{\\yn}{{\\yellow\\cat{N}}}\n\\providecommand{\\ypl}{{\\green\\cat{+}}}\n\\providecommand{\\ymi}{{\\red\\cat{-}}}\n\\providecommand{\\ypa}{{\\green\\cat{pass}}}\n\\providecommand{\\yfa}{{\\red\\cat{fail}}}\n<!-- \\providecommand{\\ypl}{\\mathord{\\green\\boldsymbol{+}}} -->\n<!-- \\providecommand{\\ymi}{\\mathord{\\red\\boldsymbol{-}}} -->\n\\providecommand{\\hi}{{\\green\\cat{high}}}\n\\providecommand{\\me}{{\\yellow\\cat{medium}}}\n\\providecommand{\\lo}{{\\red\\cat{low}}}\n\\providecommand*{\\yJ}{\\se{J}}\n\\providecommand{\\yva}{{\\lblue-1}}\n\\providecommand{\\yvb}{{\\midgrey0}}\n\\providecommand{\\yvc}{{\\yellow1}}\n\\providecommand*{\\yK}{\\se{K}}\n\\providecommand*{\\yL}{\\se{L}}\n\n\\providecommand*{\\yR}{R}\n\n\\providecommand*{\\bZ}{{\\blue Z}}\n\\providecommand*{\\bz}{{\\blue z}}\n\\providecommand*{\\rY}{{\\red Y}}\n\\providecommand*{\\bY}{{\\blue Y}}\n\\providecommand*{\\ry}{{\\red y}}\n\\providecommand*{\\gX}{{\\green X}}\n\\providecommand*{\\bX}{{\\blue X}}\n\\providecommand*{\\gx}{{\\green x}}\n\\providecommand*{\\vf}{\\vec{f}}\n<!-- \\providecommand*{\\if}{\\se{F}} -->\n\\providecommand*{\\yut}{\\se{K}_{\\textsf{3}}}\n\\providecommand*{\\yul}{\\se{K}}\n\n\\providecommand*{\\bA}{{\\blue A}}\n\\providecommand*{\\bB}{{\\blue B}}\n\\providecommand*{\\bC}{{\\blue C}}\n\n\n\\providecommand*{\\vfa}{\\vf'}\n\\providecommand*{\\vfb}{\\vf''}\n\n:::\n\n\n::: {.hidden}\n\n\\providecommand*{\\data}{\\se{\\green data}}\n\\providecommand*{\\yD}{\\se{I}_{\\textrm{d}}}\n\\providecommand*{\\ya}{k}\n\\providecommand*{\\amin}{\\ya_{\\text{mi}}}\n\\providecommand*{\\amax}{\\ya_{\\text{ma}}}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\nIt is straightforward to implement decision-making in our prototype Optimal Predictor Machine. Let's continue with the example from [chapter @sec-example-opm1].\n\n## Initialization and build of OPM agent\n\n\nLoad the necessary libraries and functions, including the `decide()` function, and train the agent as we did previously:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary('extraDistr')\nlibrary('foreach')\n\nsource('tplotfunctions.R')\nsource('guessmetadata.R')\nsource('buildagent.R')\nsource('infer.R')\nsource('decide.R')\nsource('mutualinfo.R')\nsource('rF.R')\nsource('plotFsamples1D.R')\n\noptions(repr.plot.width = 6*sqrt(2), repr.plot.height = 6)\n\nopmall <- buildagent(metadata = 'meta_income_data_example.csv',\n                     data = 'train-income_data_example.csv')\n```\n:::\n\n\n## Decision matrix\n\nWe use the targeted-advertisement scenario of [§@sec-max-exp-util-example], with the following utility matrix for the three ad-types:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadutilities <- matrix(\n    c(-1, 3,\n        2, 2,\n        3,-1),\n    nrow = 3, byrow = TRUE,\n    dimnames = list(ad_type = c('A','B','C'), income = c('<=50K', '>50K')))\n\nprint(adutilities)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       income\nad_type <=50K >50K\n      A    -1    3\n      B     2    2\n      C     3   -1\n```\n\n\n:::\n:::\n\n\n## Example application\n\nFirst let's apply the principle of maximal expected utility step-by-step.\n\nConsider the example from [§@sec-max-exp-util-example]. The agent calculates the probabilities for the predictand `income` from the given predictor values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nuserpredictors <- list(workclass = 'Private', education = 'Bachelors',\n                       marital_status = 'Never-married',\n                       occupation = 'Prof-specialty',\n                       relationship = 'Not-in-family', race = 'White',\n                       sex = 'Female', native_country = 'United-States')\n\nprobs <- infer(agent = opmall, predictand = 'income',\n               predictor = userpredictors)\n\nprint(probs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nincome\n   <=50K     >50K \n0.833333 0.166667 \n```\n\n\n:::\n:::\n\n\nFind the expected utilities of the three possible ad-types by matrix multiplication:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadutilities %*% probs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       \nad_type     [,1]\n      A -0.33333\n      B  2.00000\n      C  2.33333\n```\n\n\n:::\n:::\n\n\nAnd we see that ad-type `C` is optimal.\n\n\\\n\nThe [function `decide()`](https://github.com/pglpm/ADA511/blob/master/code/OPM-nominal/decide.R) does the previous calculations. It outputs a list with elements:\n\n- `EUs`: the expected utilities of the decisions, sorted from highest to lowest\n- `optimal`: one decision unsystematically chosen among the optimal ones (if more than one)\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptimalad <- decide(utils = adutilities, probs = probs)\n\nprint(optimalad)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$EUs\n       C        B        A \n 2.33333  2.00000 -0.33333 \n\n$optimal\n[1] \"C\"\n```\n\n\n:::\n:::\n\n\n## Performance on test set\n\nFinally let's apply our prototype agent to a test set, as a demonstration, and see how much utility it yields. This procedure will be discussed in more detail in [§@sec-eval-decision].\n\nLoad the test dataset; `M` is the number of test data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntestdata <- read.csv('test-income_data_example.csv', header = TRUE,\n    na.strings = '', stringsAsFactors = FALSE, tryLogical = FALSE)\n\nM <- nrow(testdata)\n```\n:::\n\n\nWe build the analogous of a \"confusion matrix\" ([§@sec-eval-decision]), telling us how many times the agent chooses the three ad-types for both income levels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfusionmatrix <- adutilities * 0L\n\n## Use a for-loop for clarity\nfor(i in 1:M){\n    userpredictors <- testdata[i, colnames(testdata) != 'income']\n    probs <- infer(agent = opmall, predictand = 'income',\n                   predictor = userpredictors)\n    decision <- decide(utils = adutilities, probs = probs)$optimal\n    trueincome <- testdata[i, 'income']\n\n    confusionmatrix[decision, trueincome] <- confusionmatrix[decision, trueincome] + 1L\n}\n\nprint(confusionmatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       income\nad_type <=50K >50K\n      A   769 2149\n      B 11768 5093\n      C 12961 1174\n```\n\n\n:::\n:::\n\n\nThe total utility yield is the total sum of the element-wise product of the `confusionmatrix` and the `adutilities` matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotalyield <- sum(adutilities * confusionmatrix)\naverageyield <- totalyield/M\n\ncat('\\nTotal yield =', totalyield, \n'\\nAverage yield =', averageyield, '\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nTotal yield = 77109 \nAverage yield = 2.27366 \n```\n\n\n:::\n:::\n\n\nNote that:\n\n- This yield is higher than what would be obtained by just choosing the neutral ad-type `B` for all test units (the average yield would be exactly `2`).\n\n- This yield is also higher than would be obtained by always choosing ad-type `C`, targeting the majority of units, which have `income = '<=50K'`. This strategy would yield `2.00737`.\n\n\n:::{.callout-caution}\n\n\n\n- Try to use some common machine-learning algorithm to perform the same task of choosing between the three ad-types. Is it difficult? why?\n    \n\tIf you manage to do this, then compare the performances of the machine-learning algorithm and the `opmall` agent.\n\n- Construct a scenario where the utility matrix is different depending on the `sex` predictor variate. Write a script to apply the `opmall` agent on the test set according to this new scenario.\n\n:::\n\n",
    "supporting": [
      "example_opm2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}