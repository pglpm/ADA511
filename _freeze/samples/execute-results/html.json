{
  "hash": "b0e69e96d47f84f85c3d3fe071f68d8d",
  "result": {
    "engine": "knitr",
    "markdown": "# [Infinite populations and samples]{.yellow} {#sec-pop-samples}\n::: {.hidden}\n<!-- $$\\require{mathtools}$$ -->\n\n\\providecommand{\\ul}{\\uline}\n\\providecommand{\\and}{\\mathbin{\\mkern-0.5mu,\\mkern-0.5mu}}\n\\renewcommand*{\\|}[1][]{\\nonscript\\:#1\\vert\\nonscript\\:\\mathopen{}}\n\\providecommand*{\\pr}[1]{\\textsf{\\small`#1'}}\n\\renewcommand*{\\pr}[1]{\\textsf{\\small`#1'}}\n\\providecommand*{\\prq}[1]{\\textsf{\\small #1}}\n\\providecommand*{\\se}[1]{\\mathsfit{#1}}\n\\renewcommand{\\se}[1]{\\mathsfit{#1}}\n\\providecommand*{\\sei}[1]{\\mathsfit{\\small #1}}\n<!-- \\providecommand{\\cat}[1]{\\texttt{\\small #1}} -->\n\\providecommand{\\cat}[1]{{\\small\\verb;#1;}}\n\\providecommand{\\vec}[1]{\\boldsymbol{#1}}\n\\providecommand{\\p}{\\mathrm{p}}\n\\renewcommand{\\p}{\\mathrm{p}}\n\\renewcommand{\\P}{\\mathrm{P}}\n\\definecolor{quarto-callout-note-color}{HTML}{4477AA}\n\\definecolor{quarto-callout-note-color-frame}{HTML}{4477AA}\n\\definecolor{quarto-callout-important-color}{HTML}{AA3377}\n\\definecolor{quarto-callout-important-color-frame}{HTML}{AA3377}\n\\definecolor{quarto-callout-warning-color}{HTML}{EE6677}\n\\definecolor{quarto-callout-warning-color-frame}{HTML}{EE6677}\n\\definecolor{quarto-callout-tip-color}{HTML}{228833}\n\\definecolor{quarto-callout-tip-color-frame}{HTML}{228833}\n\\definecolor{quarto-callout-caution-color}{HTML}{CCBB44}\n\\definecolor{quarto-callout-caution-color-frame}{HTML}{CCBB44}\n<!-- \\providecommand*{\\mo}[1][=]{\\mathrel{\\nonscript\\mkern-3mu\\textrm{\\small#1}\\nonscript\\mkern-3mu}} -->\n\\providecommand*{\\mo}[1][=]{\\mathclose{}\\mathord{\\nonscript\\mkern0mu\\textrm{\\small#1}\\nonscript\\mkern0mu}\\mathopen{}}\n\\providecommand*{\\yX}{\\se{X}}\n\\providecommand*{\\yY}{\\se{Y}}\n\\providecommand*{\\yI}{\\se{I}}\n\\providecommand*{\\yi}[1][]{\\se{I}_{\\text{#1}}}\n\\providecommand{\\di}{\\mathrm{d}}\n\\providecommand{\\defd}{\\coloneqq}\n\\providecommand{\\blue}{\\color[RGB]{68,119,170}}\n\\providecommand{\\red}{\\color[RGB]{238,102,119}}\n\\providecommand{\\purple}{\\color[RGB]{170,51,119}}\n\\providecommand{\\green}{\\color[RGB]{34,136,51}}\n\\providecommand{\\yellow}{\\color[RGB]{204,187,68}}\n\\providecommand{\\lblue}{\\color[RGB]{102,204,238}}\n\\providecommand{\\grey}{\\color[RGB]{187,187,187}}\n\\providecommand{\\midgrey}{\\color[RGB]{119,119,119}}\n\\providecommand{\\black}{\\color[RGB]{0,0,0}}\n\\providecommand*{\\e}{\\mathrm{e}}\n\\providecommand*{\\pu}{\\text{π}}\n\\providecommand*{\\RR}{\\mathbf{R}}\n\n$\\DeclarePairedDelimiter{\\set}{\\{}{\\}}$\n\\providecommand*{\\argmax}{\\operatorname{argmax}}\n<!-- \\DeclareMathOperator*{\\argmax}{argmax} -->\n\n<!-- \\renewcommand*{\\prq}[1]{\\textsf{\\small #1}} -->\n<!-- \\definecolor{lightblue}{HTML}{66CCEE} -->\n<!-- \\sethlcolor{lightblue} -->\n<!-- \\providecommand*{\\moo}[1][=]{\\mathord{\\mkern1.5mu#1\\mkern1.5mu}} -->\n<!-- \\providecommand*{\\mo}[1][=]{\\mathrel{\\mkern-4mu#1\\mkern-4mu}} -->\n<!-- \\providecommand*{\\mo}[1][\\textrm{\\small=}]{\\mathord{\\mkern1.5mu#1\\mkern1.5mu}} -->\n\n:::\n\n::: {.hidden}\n<!-- $$\\require{mathtools}$$ -->\n\n\\providecommand{\\yXv}[1]{X^{(#1)}}\n\\providecommand{\\vRI}{\\mathit{RI}}\n\\providecommand{\\vCa}{\\mathit{Ca}}\n\\providecommand{\\vSi}{\\mathit{Si}}\n\\providecommand{\\vType}{\\mathit{Type}}\n\n\\providecommand{\\vage}{\\mathit{age}}\n\\providecommand{\\vrace}{\\mathit{race}}\n\\providecommand{\\vsex}{\\mathit{sex}}\n\\providecommand{\\vincome}{\\mathit{income}}\n\\providecommand{\\owhite}{\\cat{White}}\n\\providecommand{\\oblack}{\\cat{Black}}\n\\providecommand{\\oesk}{\\cat{Amer-Indian-Eskimo}}\n\\providecommand{\\oM}{\\cat{M}}\n\\providecommand{\\oF}{\\cat{F}}\n\\providecommand{\\ohi}{\\cat{`>50K'}}\n\\providecommand{\\olo}{\\cat{`<=50K'}}\n\n\\providecommand{\\vOut}{\\mathit{\\red Outcome}}\n\\providecommand{\\vMet}{\\mathit{\\green Method}}\n\\providecommand{\\vLoc}{\\mathit{\\lblue Location}}\n\n\\providecommand{\\osuccess}{\\red\\cat{success}}\n\\providecommand{\\ofailure}{\\red\\cat{fail}}\n\\providecommand{\\onew}{{\\green\\cat{new}}}\n\\providecommand{\\oold}{{\\green\\cat{old}}}\n\\providecommand{\\oonsite}{{\\lblue\\cat{onsite}}}\n\\providecommand{\\oremote}{{\\lblue\\cat{remote}}}\n\n:::\n\n::: {.hidden}\n\\providecommand{\\yA}{\\se{A}}\n\\providecommand{\\yB}{\\se{B}}\n\\providecommand{\\fail}{\\cat{fail}}\n\\providecommand{\\work}{\\cat{work}}\n\\providecommand{\\high}{\\cat{high}}\n\\providecommand{\\medium}{\\cat{medium}}\n\\providecommand{\\low}{\\cat{low}}\n\\providecommand{\\HH}{\\mathrm{H}}\n:::\n\n\n## Infinite populations {#sec-infinite-populations}\n\nThe examples of populations that we explored so far comprised a small number of units, and all their data were exactly and fully known. In concrete inference and decision problems of the kind we have been focusing on in chapters [-@sec-learning] and [-@sec-3-connection-ML], we usually deal with populations that are much larger or potentially infinite; and data are known only for a small collection of their units.\n\nIn the glass-forensic example ([table @tbl-glass]), for instance, many more glass fragments could be examined beyond the 10 units reported there, with no clear bound on the total number. We could even extend that population considering glass fragments from past and future crime scenes:\n\n:::{.column-page-right}\n| [unit]{.yellow} |     $\\vRI$  |  $\\vCa$   |   $\\vSi$  |                               $\\vType$   | [*notes*]{.small}\n|:--:|:-------:|:-----:|:-----:|:------------------------------------:|:-----------------------:|\n|   [1]{.yellow}  |  $1.51888$  |   $9.95$  |  $72.50$  |                             $\\cat{tableware}$  |\n|   [2]{.yellow}  |  $1.51556$  |   $9.41$  |  $73.23$  |                             $\\cat{headlamps}$  | |\n|   [3]{.yellow}  |  $1.51645$  |   $8.08$  |  $72.65$  |  $\\cat{building_windows_non_float_processed}$  | |\n|   [4]{.yellow}  |  $1.52247$  |   $9.76$  |  $70.26$  |                             $\\cat{headlamps}$  | |\n|   [5]{.yellow}  |  $1.51909$  |   $8.78$  |  $71.81$  |      $\\cat{building_windows_float_processed}$  | |\n|   [6]{.yellow}  |  $1.51590$  |   $8.22$  |  $73.10$  |  $\\cat{building_windows_non_float_processed}$  | |\n|   [7]{.yellow}  |  $1.51610$  |   $8.32$  |  $72.69$  |       $\\cat{vehicle_windows_float_processed}$  | |\n|   [8]{.yellow}  |  $1.51673$  |   $8.03$  |  $72.53$  |  $\\cat{building_windows_non_float_processed}$  | |\n|   [9]{.yellow}  |  $1.51915$  |  $10.09$  |  $72.69$  |                            $\\cat{containers}$  | |\n|  [10]{.yellow}  |  $1.51651$  |   $9.76$  |  $73.61$  |                             $\\cat{headlamps}$  | |\n|     ...         |    ...      |    ...    |    ...    |                                 ...      | ...|\n| [351]{.yellow} |  $1.52101$  |   $8.75$  |  $71.78$  |                                [?]{.red}  | [*from unsolved-crime scene in 1963*]{.small}|\n|     ...         |    ...      |    ...    |    ...    |                                 ...      | ... |\n| [1027]{.yellow} |  $1.51761$  |   $7.83$  |  $72.73$  |                               [?]{.red}  | [*crime scene in 2063*]{.small}|\n|     ...         |    ...      |    ...    |    ...    |                                 ...      |... |\n: Glass fragments, extended {#tbl-glass-ext .sm}\n:::\n\nthe imaginary example above also shows that the values of some variates for some units might be unknown; this is a situation we shall discuss in depth later.\n\n\\\n\nWe shall henceforth focus on statistical populations with a number of units that is *in principle infinite*, or so large that it can be considered *practically infinite*. \"Practically\" means that the number of units we'll use as data or draw inferences about is a very small fraction, say less than 0.1%, of the total population size.\n\n[This is often the case. Consider for example (as in [§@sec-quant-value-dom]) the collection of all possible 128 × 128 images with 24-bit [colour depth](https://www.cambridgeincolour.com/tutorials/bit-depth.htm). This collection has $2^{24 \\times 128 \\times 128} \\approx 10^{118 370}$ units. Even if we used 100 billions of such images as data, and wanted to draw inferences on another 100 billions, these would constitute only $10^{-118 357}\\,\\%$ of the whole collection. This collection is practically infinite.]{.small}\n\nNote that we can't say whether a population, per se, is \"practically infinite\" or not. It could be practically infinite for a particular inference problem, but not for another.\n\nWhen we use the term \"population\" it will often be understood that we're speaking about a statistical population that is practically infinite with respect to the inference or decision problem under consideration.\n\n\n## Limit frequencies {#sec-limit-freqs}\n\nIn [§@sec-freq-distr] we defined relative frequencies. Relative frequencies are ratios of two integers, the denominator being the population size $N$. So a frequency $f$ can only take on $N+1$ rational values $0/N, \\dotsc, N/N$ between $0$ and $1$. As the population size increases, the number of distinct, possible frequencies increases and eventually can be considered practically continuous. Frequencies in this case are sometimes called **limit frequencies** and they are treated as real numbers between $0$ and $1$.\n\n\n\n\n<!-- It is then useful to proceed as is [§@sec-prob-densities] and use a  [**frequency density**]{.blue} $f(v)$ defined as -->\n\n<!-- $$ -->\n<!-- f(v) -->\n<!-- \\defd -->\n<!-- \\frac{ -->\n<!-- \\text{\\small absolute frequency of all values between \\(v-\\epsilon/2\\) and \\(v+\\epsilon/2\\)} -->\n<!-- }{\\epsilon} -->\n<!-- $$ -->\n\n<!-- The discussion of [§@sec-prob-densities] about densities applies also in the case of frequency distributions. -->\n\n\n## Samples {#sec-samples}\n\n### Learning from samples\n\nIn chapters [-@sec-learning] and [-@sec-3-connection-ML] we considered an agent that must draw an inference about some units from a population. The agent's degrees of belief in that inference relied (that is, were conditional on) units already observed in the population, the \"learning\" or \"training\" data. We saw that the agent's degrees of belief changed, often becoming sharper, thanks to the information about the observed units.\n\nUnits for which we have full (or almost full) information, and that an agent can use to update its beliefs, are called a [**population sample**]{.blue} or \"sample\" for short. Almost all data considered in engineering and data-science problems can be considered to be population samples.\n\nIt is extremely important to **specify how a sample is extracted or collected** from a population. For instance, if we consider [table @tbl-glass] to be a full population, we could extract a sample in such a way that $\\vType$ only has value $\\cat{headlamps}$ (similarly to when we construct a subpopulation, [§@sec-subpopulations], but for a subpopulation we would select *all* units having that variate value). The marginal frequency of the value $\\cat{headlamps}$ in the sample would then be $1$, whereas in the original population it is $3/10 \\approx 0.333$ -- two very different frequencies.\n\n\n### \"Representative\" and biased samples\n\nIf samples from a population are used as conditional information to calculate probabilities about other units, then they should of course be \"relevant\", in some sense (not the technical sense of [chapter @sec-info-chapter]), for the inference. The very *definition* of statistical population ([§@sec-variates-populations]) is meant to have such a relevance built-in: the \"similarity\" of the units makes each of them relevant for inferences about any other.\n\nStill, the procedure with which samples are selected from a population may lead to quirky and unreasonable inferences. For instance suppose we are interested in prognosing a disease for a person from a particular population, having observed a sample of people from the same population. If the sample was *chosen* to consist only of people having the disease, then it is obviously meaningless for our inference.\n\nThe specific problem in this example is that our inference is based on guessing a frequency distribution in the full population (as we'll see more in detail in later chapters), but the sample, owing to the way it was chosen, cannot show a frequency distribution similar to the full-population frequency distribution.\n\n\\\n\nA sampling procedure may generate a sample that is pointless for some inferences, but still useful for others.\n\nIn the inference and decision problems under our focus we would like to use a sample for which particular frequencies -- most often the full joint frequency -- don't differ very much from those in the full population. We'll informally call this a \"[representative sample]{.blue}\". This is a difficult notion; the International Organization for Standardization for instance [warns (item 3.1.14)](https://www.iso.org/obp/ui/#iso:std:iso:3534:-4:ed-1:v1:en):\n\n> The notion of representative sample is fraught with controversy, with some survey practitioners rejecting the term altogether.\n\n\\\n\nIn many cases it is *impossible* for a sample of given size to be fully \"representative\":\n\n:::{.callout-caution}\n## {{< fa user-edit >}} Exercise\n\nConsider the following population of 16 units, with four binary variates $W,X,Y,Z$, each with values $0$ and $1$:\n\n::::{.columns}\n:::::{.column width=\"75%\"}\n|$W$|$X$|$Y$|$Z$|\n|:-:|:-:|:-:|:-:|\n| 0 | 0 | 0 | 0 |\n| 1 | 0 | 0 | 0 |\n| 0 | 1 | 0 | 0 |\n| 1 | 1 | 0 | 0 |\n| 0 | 0 | 1 | 0 |\n| 1 | 0 | 1 | 0 |\n| 0 | 1 | 1 | 0 |\n| 1 | 1 | 1 | 0 |\n| 0 | 0 | 0 | 1 |\n| 1 | 0 | 0 | 1 |\n| 0 | 1 | 0 | 1 |\n| 1 | 1 | 0 | 1 |\n| 0 | 0 | 1 | 1 |\n| 1 | 0 | 1 | 1 |\n| 0 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 1 |\n: Four-bit population {#tbl-four-bit .sm}\n:::::\n::::\n\nThe joint variate $(W,X,Y,Z)$ has 16 possible values, from $(0,0,0,0)$ to $(1,1,1,1)$. Each of these values appear exactly once in the population, so it has frequency $1/16$. The marginal frequency distribution for each binary variate is also uniform, with frequencies of 50% for both $0$ and $1$.\n\n- Extract a **representative** sample of size **four** units. In particular, the marginal frequency distributions of the four variates should be as close to 50%/50% as possible.\n:::\n\nLuckily, the probability calculus allows an agent to draw inferences also when the sample is too small to correctly reflect full-population frequencies, if appropriate *background information* is provided.\n\n\\\n\nObviously we cannot expect a population sample to exactly reflect all frequency distributions -- joint, marginal, conditional -- of the original population; some discrepancy is to be expected. How much discrepancy should be allowed? And what is the minimal size for a sample not to exceed such discrepancy?\n\nInformation Theory, briefly mentioned in [chapter @sec-info-chapter], can give reasonable answers to these questions. Let us summarize some examples here.\n\n::::{.column-margin}\n::: {.callout-tip}\n## {{< fa rocket >}} For the extra curious\n\n- Chapters 1--10 of [*Information Theory, Inference, and Learning Algorithms*](references.html)\n\n- Video lectures 1--9 from the [*Course on Information Theory, Pattern Recognition, and Neural Networks*](http://videolectures.net/course_information_theory_pattern_recognition/)\n\n:::\n::::\n\n\nFirst we need to introduce the Shannon entropy of a discrete *frequency* distribution. It is defined in a way analogous to the Shannon entropy for a discrete *probability* distribution, discussed in [§@sec-entropy-mutualinfo]. Lets say the distribution is $\\vec{f} \\defd (f_1,f_2, \\dotsc)$. Its Shannon entropy $\\HH(\\vec{f})$ is\n\n$$\n\\HH(\\vec{f}) \\defd -\\sum_{i} f_i\\ \\log_2 f_i\n\\qquad\\text{\\midgrey\\small(with \\(0\\cdot\\log 0 \\defd 0\\))}\n$$\n\nand is measured in **shannons** when the base of the logarithm is 2.\n\nIf we have a population with joint frequency distribution $\\vec{f}$, then a representative sample from it must have at least size\n\n$$\n2^{\\HH(\\vec{f})} \\equiv\n\\frac{1}{{f_1}^{f_1}\\cdot {f_2}^{f_2}\\cdot {f_3}^{f_3}\\cdot \\dotsb}\n$$\n<!-- \\frac{1}{\\prod_i{f_i}^{f_i}} = -->\n\nThis particular number has important practical consequences; for example it is related to the maximum rate at which a communication channel can send symbols (which can be considered as values of a variate) with an error as low as we please.\n\n:::{.callout-caution}\n## {{< fa user-edit >}} Exercise\n- Calculate the Shannon entropy of the joint frequency distribution for the four-bit population of [table @tbl-four-bit].\n\n- Calculate the minimum representative-sample size according to the Shannon-entropy formula. Is the result intuitive?\n:::\n\n\\\n\nIf we are only interested in a smaller number of variates of a population, then the representative sample can be smaller as well: its size would be given by the entropy of the corresponding *marginal* frequency distribution of the variates of interest. In the example of [table @tbl-four-bit], if we are only interested in the variate $X$, then any sample consisting of two units, one having $X\\mo0$ and the other having $X\\mo1$, would be a representative sample of the marginal frequency distribution $f(X)$.\n\n::: {.callout-warning}\n## {{< fa book >}} Study reading\nKruskal & al. 1979: [*Representative Sampling, I*](references.html)\n:::\n\n\nA sample that presents some aspects, such as frequency distributions, which are at variance with the original population, is sometimes called [biased]{.blue}. This term is used in many different ways by different authors. Unfortunately, most samples are \"biased\" in this sense.\n\nThe only way to counteract the misleading information given by a biased sample is to specify appropriate **background information**, which comes not from data samples but from a general meta-analysis, often based on physical, medical, and similar principles, of the problem and population.\n\n\\\n\n\n\n### Quirks of samples for mean and standard deviation\n\nFor some populations, the mean and standard deviation calculated in a sample can be wildly different from those of the full population -- even when the sample comprises half of the full population! This does not happen with the median and quartiles. Here is a demonstration in `R`. Try it out in your favourite programming language.\n\n:::{.callout-caution}\n## {{< fa user-edit >}} Guided exercise\n\nWe imagine to have a population of 1 000 000 units. These units have continuous interval variates $X$ and $Y$, each with an approximately standard Gaussian frequency distribution. These variates are not actual part of the population definition, however. Rather, an agent only has access to, or maybe it's only interested in, the ratio of these two variates $Z \\defd X/Y$.\n\nThe agent is in particular interested in the *mean* of the variate $Z$ in the full population, but has only access to the values of $Z$ in a sample. How does the mean calculated from a sample of increasing size compare with the actual mean of the full population? For comparison, we also study the *median* of the full population and of the samples.\n\nFirst let's create the values of the variates $X$ and $Y$, and construct $Z$ from them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Load custom plot functions\nsource('code/tplotfunctions.R')\nset.seed(1000) # to reproduce results\n\nN <- 1000000 # population size\n\nX <- rnorm(N) # variate invisible to agent\nY <- rnorm(N) # variate invisible to agent\n\nZ <- X / Y # variate considered by agent\n\n## mean and median of Z in the full population\npopmean <- mean(Z)\ncat('\\nThe full-population mean is', popmean, '(unknown to the agent)\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nThe full-population mean is -8.04481 (unknown to the agent)\n```\n\n\n:::\n\n```{.r .cell-code}\npopmedian <- median(Z)\ncat('\\nThe full-population median is', popmedian, '(unknown to the agent)\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nThe full-population median is 0.00188701 (unknown to the agent)\n```\n\n\n:::\n:::\n\n\nNow we imagine that the agent accumulates samples from the population, starting from 100, increasing by 100 units, until half of the population has been sampled. At each sample increase the agent calculates the sample mean. We plot how the sample mean changes with the sample size. We also plot indicate the full-population mean, which the agent doesn't know and is trying to guess:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## sizes of successive samples\nsamplesizes <- seq(from = 100, to = N / 2, by = 100)\n\n## empty vectors to contain the means and medians of the increasing samples\nsamplemeans <- numeric(length(samplesizes))\nsamplemedians <- numeric(length(samplesizes))\n\n## loop through the increasing samples, calculate mean for each\nfor(sample in seq_along(samplesizes)){\n    samplemeans[sample] <- mean(Z[1:samplesizes[sample]])\n    samplemedians[sample] <- median(Z[1:samplesizes[sample]])\n\n}\n\n## plot how sample means change with sample size, and the actual population mean\ncommonmax <- 1.01 * max(abs(c(popmean, popmedian, samplemeans, samplemedians)))\nmyflexiplot(x = samplesizes, y = samplemeans,\n      xlab = 'sample size', ylab = 'sample mean',\n      col = 2, lwd = 4,\n      ylim = c(-commonmax, commonmax))\nabline(h = popmean, lty = 2, lwd = 3, col = 7)\ntext(y = popmean, x = max(samplesizes),\n    labels = 'population mean (unknown to agent)',\n    adj = c(1, 1), col = 7, cex = 1.2)\n```\n\n::: {.cell-output-display}\n![](samples_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\n## plot how sample medians change with sample size, and the actual population median\nmyflexiplot(x = samplesizes, y = samplemedians,\n      xlab = 'sample size', ylab = 'sample median',\n      col = 3, lwd = 4,\n      ylim = c(-commonmax, commonmax))\nabline(h = popmedian, lty = 2, lwd = 3, col = 7)\ntext(y = popmedian, x = max(samplesizes),\n    labels = 'population median (unknown to agent)',\n    adj = c(1, 1), col = 7, cex = 1.2)\n```\n\n::: {.cell-output-display}\n![](samples_files/figure-html/unnamed-chunk-2-2.png){width=672}\n:::\n:::\n\n\nTest this again with several pseudorandom seeds.\n\n\\\n\n- Now try a similar exercise but for the standard deviation of $Z$\n\n:::\n",
    "supporting": [
      "samples_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}